function(dump_cmake_variables)
  set(options VERBOSE)
  set(oneValueArgs REGEX OUTPUT_VAR LOG_LEVEL)
  set(multiValueArgs VARIABLES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  if(NOT ARGS_LOG_LEVEL)
    set(ARGS_LOG_LEVEL STATUS)
  endif()
  if(ARGS_VARIABLES)
    set(_variableNames ${ARGS_VARIABLES})
  else()
    get_cmake_property(_variableNames VARIABLES)
  endif()
  list (SORT _variableNames)
  if(NOT ARGS_OUTPUT_VAR)
    set(ARGS_VERBOSE ON)
  endif()
  foreach (_variableName ${_variableNames})
    if (ARGS_REGEX)
      unset(MATCHED)
      string(REGEX MATCH ${ARGS_REGEX} MATCHED ${_variableName})
      if (NOT MATCHED)
        continue()
      endif()
    endif()
    if (ARGS_VERBOSE)
      message(${ARGS_LOG_LEVEL} "${_variableName}=${${_variableName}}")
    endif()
    if (ARGS_OUTPUT_VAR)
      list(APPEND ${ARGS_OUTPUT_VAR} ${_variableName})
    endif()
  endforeach()
  if (ARGS_OUTPUT_VAR)
    set(${ARGS_OUTPUT_VAR} ${${ARGS_OUTPUT_VAR}} PARENT_SCOPE)
  endif()
endfunction()

macro(propagate_cmake_variables)
  set(_temp_package_vars "${ARGN}")
  foreach (_variableName IN LISTS _temp_package_vars)
    set(${_variableName} ${${_variableName}} PARENT_SCOPE)
  endforeach()
endmacro()

macro(propagate_cmake_library_variables NAME)
  set(_temp_package_vars "${ARGN}")
  dump_cmake_variables(
    REGEX ${NAME} OUTPUT_VAR _temp_package_vars
  )
  foreach (_variableName IN LISTS _temp_package_vars)
    set(${_variableName} ${${_variableName}} PARENT_SCOPE)
  endforeach()
endmacro()

function(add_library_python target)
    if (NOT Python_PREFIX)
      set(Python_PREFIX Python)
      set(Python_PREFIX Python PARENT_SCOPE)
    endif()
    cmake_parse_arguments(
      ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    if (Python_PREFIX STREQUAL "Python3")
      Python3_add_library(${target} ${ARGS_UNPARSED_ARGUMENTS})
    else()
      Python_add_library(${target} ${ARGS_UNPARSED_ARGUMENTS})
    endif()
endfunction()

function(find_package_python)
    # needed on GitHub Actions CI: actions/setup-python does not touch registry/frameworks on Windows/macOS
    # this mirrors PythonInterp behavior which did not consult registry/frameworks first
    if (NOT Python_PREFIX)
      set(Python_PREFIX Python)
      set(Python_PREFIX Python PARENT_SCOPE)
    endif()
    if (NOT DEFINED ${Python_PREFIX}_FIND_REGISTRY)
        set(${Python_PREFIX}_FIND_REGISTRY "LAST")
    endif ()
    if (NOT DEFINED ${Python_PREFIX}_FIND_FRAMEWORK)
        set(${Python_PREFIX}_FIND_FRAMEWORK "LAST")
    endif ()
    if(${Python_PREFIX}_EXECUTABLE)
        message(DEBUG "Python executable provided ${${Python_PREFIX}_EXECUTABLE}")
        if(NOT ${Python_PREFIX}_NumPy_INCLUDE_DIRS)
	    execute_process(
	      COMMAND ${${Python_PREFIX}_EXECUTABLE} -c "import numpy; print(numpy.get_include())"
	      OUTPUT_VARIABLE ${Python_PREFIX}_NumPy_INCLUDE_DIRS
	      RESULT_VARIABLE NUMPY_NOT_FOUND)
            if(NUMPY_NOT_FOUND)
                message(FATAL_ERROR "Numpy include dirs not found")
            endif()
        endif()
    else()
        if(NOT ${Python_PREFIX}_ROOT_DIR)
            if(CONDA_PREFIX)
                set(${Python_PREFIX}_ROOT_DIR "${CONDA_PREFIX}")
            else()
                if(${Python_PREFIX}_EXECUTABLE)
		    execute_process(
		      COMMAND ${${Python_PREFIX}_EXECUTABLE} -c "import sysconfig; print(sysconfig.get_config_var('base'))"
		      OUTPUT_VARIABLE Python_ROOT
		      RESULT_VARIABLE ROOT_NOT_FOUND)
                    if(ROOT_NOT_FOUND)
                        message(FATAL_ERROR "Python root not found")
                    endif()
	            set(${Python_PREFIX}_ROOT_DIR "${Python_ROOT}")
                endif()
            endif()
        endif()
    endif()
    if(${Python_PREFIX}_EXECUTABLE OR ${Python_PREFIX}_ROOT_DIR)
        # Force use of specified installation, should be enabled by
	# default for CMP0094=NEW and CMake >= 3.15
        if(NOT ${Python_PREFIX}_FIND_STRATEGY)
            set(${Python_PREFIX}_FIND_STRATEGY LOCATION)
        endif()
    endif()
    if(${Python_PREFIX}_ROOT_DIR)
        message(DEBUG "Python root directory is ${${Python_PREFIX}_ROOT_DIR}")
        if (NOT ${Python_PREFIX}_ROOT)
            set(${Python_PREFIX}_ROOT ${${Python_PREFIX}_ROOT_DIR})
        endif()
    endif()
    find_package(${Python_PREFIX} COMPONENTS Interpreter Development NumPy REQUIRED)
    if(NOT ${Python_PREFIX}_NumPy_FOUND)
        message(FATAL_ERROR "NumPy headers not found")
    endif()
    if(NOT ${Python_PREFIX}_FOUND)
        message(FATAL_ERROR "Python libraries not found")
    endif()
    if (APPLE AND ${Python_PREFIX}_EXECUTABLE)
      execute_process(
        COMMAND realpath ${${Python_PREFIX}_EXECUTABLE}
	OUTPUT_VARIABLE ${Python_PREFIX}_EXECUTABLE_FULL
	RESULT_VARIABLE ERROR_IN_FULL
	OUTPUT_STRIP_TRAILING_WHITESPACE)
      if ((NOT ERROR_IN_FULL) AND (NOT ${Python_PREFIX}_EXECUTABLE STREQUAL "${${Python_PREFIX}_EXECUTABLE_FULL}"))
        set(${Python_PREFIX}_EXECUTABLE ${${Python_PREFIX}_EXECUTABLE_FULL})
      endif()
    endif()
    message(STATUS "${Python_PREFIX}_EXECUTABLE = ${${Python_PREFIX}_EXECUTABLE}")
    propagate_cmake_library_variables("^Python*")
endfunction()

function(finalize_package name)
  set(oneValueArgs HEADER IMPORTED_TARGET)
  set(multiValueArgs LIBNAMES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  if(${name}_FOUND AND ARGS_IMPORTED_TARGET)
    create_interface_library(
      ${name} TARGET ${ARGS_IMPORTED_TARGET}
      LIBNAMES ${ARGS_LIBNAMES}
    )
  endif()
  if(${name}_FOUND AND NOT ${name}_LIBRARY_TARGET)
    foreach(itarget ${ARGS_IMPORTED_TARGET} ${name}
            ${ARGS_LIBNAMES} ${${name}_LIBRARY})
      if(TARGET ${itarget})
        set(${name}_LIBRARY_TARGET ${itarget})
        break()
      endif()
    endforeach()
  endif()
  propagate_cmake_library_variables("^${name}*" ${ARGS_ADDITIONAL_PROPERTIES})
endfunction()

function(create_interface_library package)
  set(oneValueArgs TARGET)
  set(multiValueArgs LIBNAMES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  set(target ${package})
  if(ARGS_TARGET)
    set(target ${ARGS_TARGET})
  endif()
  # From current scope variables
  if(TARGET ${target})
    message(DEBUG "${target} is already a target")
    return()
  endif()
  if(${package}_LIBRARY AND TARGET ${${package}_LIBRARY})
    message(DEBUG "Creating target \"${target}\" by aliassing \"${${package}_LIBRARY}\"")
    add_library(${target} ALIAS ${${package}_LIBRARY})
    return()
  endif()
  foreach(ilib IN LISTS ARGS_LIBNAMES)
    if(TARGET ${ilib})
      message(DEBUG "Creating target \"${target}\" by aliassing \"${ilib}\"")
      add_library(${target} ALIAS ${ilib})
      return()
    endif()
  endforeach()
  message(DEBUG "Creating target \"${target}\" from the variables in scope for package \"${package}\"")
  dump_cmake_variables(REGEX "^${package}*" LOG_LEVEL DEBUG)
  add_library(${target} INTERFACE IMPORTED GLOBAL)
  if(${package}_LIBRARY)
    if(WIN32 AND NOT ${package}_IMPLIB)
      string(FIND ${${package}_LIBRARY} ".dll" DLL_IDX)
      if(DLL_IDX EQUAL -1)
        find_dll_from_implib(${${package}_LIBRARY} dlllib)
        if(dlllib)
          set(${package}_IMPLIB ${${package}_LIBRARY})
          set(${package}_LIBRARY ${dlllib})
        endif()
      else()
        find_implib_from_dll(${${package}_LIBRARY} implib)
        if(implib)
          set(${package}_IMPLIB ${implib})
        endif()
      endif()
    endif()
    set_target_properties(
      ${target} PROPERTIES
      IMPORTED_LOCATION ${${package}_LIBRARY}
    )
  endif()
  if(WIN32 AND ${package}_IMPLIB)
    set_target_properties(
      ${target} PROPERTIES
      IMPORTED_IMPLIB ${${package}_IMPLIB}
    )
  endif()
  if(${package}_LIBRARIES)
    add_dependencies(${target} ${${package}_LIBRARIES})
  endif()
  if(${package}_LIBRARY_DIRS)
    set_target_properties(
      ${target} PROPERTIES
      INTERFACE_LINK_DIRECTORIES ${${package}_LIBRARY_DIRS}
    )
  endif()
  if(${package}_LINK_LIBRARIES)
    set_target_properties(
      ${target} PROPERTIES
      INTERFACE_LINK_LIBRARIES ${${package}_LINK_LIBRARIES}
    )
  endif()
  if(${package}_LDFLAGS)
    set_target_properties(
      ${target} PROPERTIES
      INTERFACE_LINK_OPTIONS ${${package}_LDFLAGS}
      # ${${package}_LDFLAGS_OTHER}  # Not required
    )
  endif()
  if(${package}_INCLUDE_DIRS)
    set_target_properties(
      ${target} PROPERTIES
      INTERFACE_INCLUDE_DIRECTORIES ${${package}_INCLUDE_DIRS}
    )
  endif()
  if(${package}_CFLAGS)
    set_target_properties(
      ${target} PROPERTIES
      INTERFACE_COMPILE_OPTIONS ${${package}_CFLAGS}
      # ${${package}_CFLAGS_OTHER}  # Not required
    )
  endif()
  propagate_cmake_library_variables("^${name}*")
endfunction()

function(find_package_generic name)
  set(options REQUIRED NO_DEFAULT NO_PKGCONFIG NO_CONDA)
  set(oneValueArgs HEADER IMPORTED_TARGET)
  set(multiValueArgs LIBNAMES SEARCH_ORDER ADDITIONAL_PROPERTIES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  if (NOT ARGS_LIBNAMES)
    list(APPEND ARGS_LIBNAMES ${name})
  endif()
  if (NOT ARGS_HEADER)
    list(GET ARGS_LIBNAMES 0 FIRST_NAME)
    set(ARGS_HEADER ${FIRST_NAME}.h)
  endif()
  if(NOT ARGS_SEARCH_ORDER)
    set(ARGS_SEARCH_ORDER DEFAULT PKGCONFIG CONDA)
  endif()
  set(SEARCH_ARGS LIBNAMES ${LIBNAMES} HEADER ${HEADER})
  if(ARGS_IMPORTED_TARGET)
    list(APPEND SEARCH_ARGS IMPORTED_TARGET ${ARGS_IMPORTED_TARGET})
  endif()
  if(ARGS_ADDITIONAL_PROPERTIES)
    list(APPEND SEARCH_ARGS ADDITIONAL_PROPERTIES ${ARGS_ADDITIONAL_PROPERTIES})
  endif()
  if(ARGS_UNPARSED_ARGUMENTS)
    list(APPEND SEARCH_ARGS ${ARGS_UNPARSED_ARGUMENTS})
  endif()
  message(DEBUG "find_package_generic[${name}]: HEADER = ${ARGS_HEADER}, LIBNAMES = ${ARGS_LIBNAMES}, SEARCH_ORDER = ${ARGS_SEARCH_ORDER}, UNPARSED_ARGUMENTS = ${ARGS_UNPARSED_ARGUMENTS}")

  foreach(method IN LISTS ARGS_SEARCH_ORDER)
    if(ARGS_NO_${method})
      continue()
    endif()
    message(DEBUG "Searching for ${name} using ${method}")
    if(method STREQUAL "DEFAULT")
      find_package(${name} ${ARGS_UNPARSED_ARGUMENTS})
    elseif(method STREQUAL "DEFAULT_CONFIG")
      find_package(${name} CONFIG ${ARGS_UNPARSED_ARGUMENTS})
    elseif(method STREQUAL "CONDA")
      find_package_conda(${name} ${SEARCH_ARGS})
    elseif(method STREQUAL "PKGCONFIG")
      find_package_pkgconfig(${name} ${SEARCH_ARGS})
    elseif(method STREQUAL "BRUTE")
      find_package_brute(${name} ${SEARCH_ARGS})
    else()
      message(FATAL_ERROR "Unsupported method \"${method}\"")
    endif()
    if(${name}_FOUND)
      message(DEBUG "${name} found using ${method}")
      break()
    endif()
  endforeach()

  if(${name}_CONFIG)
    message(DEBUG "${name}_CONFIG = ${${name}_CONFIG}")
    include(${${name}_CONFIG})
  endif()

  if((NOT ${name}_FOUND) AND (NOT ${name}_BRUTE_SEARCH_PERFORMED))
    message(DEBUG "Final brute force effort to find ${name}")
    find_package_brute(${name} ${SEARCH_ARGS})
  endif()

  if(ARGS_REQUIRED AND NOT ${name}_FOUND)
    message(FATAL_ERROR "Failed to find package \"${name}\"")
  endif()

  finalize_package(
    ${name}
    HEADER ${ARGS_HEADER}
    LIBNAMES ${ARGS_LIBNAMES}
    IMPORTED_TARGET ${ARGS_IMPORTED_TARGET}
  )
  dump_cmake_variables(REGEX "^${name}*" LOG_LEVEL DEBUG)
  propagate_cmake_library_variables("^${name}*" ${ARGS_ADDITIONAL_PROPERTIES})
endfunction()

function(find_package_brute name)
  set(options REQUIRED)
  set(oneValueArgs HEADER IMPORTED_TARGET)
  set(multiValueArgs LIBNAMES LIBRARY_SEARCH_PATH HEADER_SEARCH_PATH)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  if (NOT ARGS_LIBNAMES)
    list(APPEND ARGS_LIBNAMES ${name})
  endif()
  if (NOT ARGS_HEADER)
    list(GET ARGS_LIBNAMES 0 FIRST_NAME)
    set(ARGS_HEADER ${FIRST_NAME}.h)
  endif()

  if(NOT ${name}_INCLUDE_DIR)
    find_path(
      ${name}_INCLUDE_DIR
      NAMES ${ARGS_HEADER}
      PATHS ${ARGS_HEADER_SEARCH_PATH}
    )
    if(${name}_INCLUDE_DIR STREQUAL "${name}_INCLUDE_DIR-NOTFOUND")
      message(DEBUG "Failed to find ${name}_INCLUDE_DIR")
      foreach(dir IN LISTS ARGS_HEADER_SEARCH_PATH)
        execute_process(
          COMMAND ls ${dir}
          COMMAND_ECHO STDOUT
        )
      endforeach()
      set(${name}_INCLUDE_DIR)
    elseif(NOT ${name}_INCLUDE_DIRS)
      set(${name}_INCLUDE_DIRS ${${name}_INCLUDE_DIR})
    endif()
  endif()

  if(NOT ${name}_LIBRARY)
    find_library(
      ${name}_LIBRARY
      NAMES ${ARGS_LIBNAMES}
      PATHS ${ARGS_LIBRARY_SEARCH_PATH}
      NO_CACHE
    )
    if(${name}_LIBRARY STREQUAL "${name}_LIBRARY-NOTFOUND")
      message(DEBUG "Failed to find ${name}_LIBRARY")
      foreach(dir IN LISTS ARGS_LIBRARY_SEARCH_PATH)
        execute_process(
          COMMAND ls ${dir}
          COMMAND_ECHO STDOUT
        )
      endforeach()
      set(${name}_LIBRARY)
    endif()
  endif()

  if(${name}_INCLUDE_DIR AND ${name}_LIBRARY)
    set(${name}_FOUND ON)
  endif()

  if(ARGS_REQUIRED AND NOT ${name}_FOUND)
    message(STATUS "Failed to find package \"${name}\"")
  endif()
  set(${name}_BRUTE_SEARCH_PERFORMED ON)
  
  finalize_package(
    ${name}
    HEADER ${ARGS_HEADER}
    LIBNAMES ${ARGS_LIBNAMES}
    IMPORTED_TARGET ${ARGS_IMPORTED_TARGET}
  )
  propagate_cmake_library_variables("^${name}*")
endfunction()

function(find_package_conda name)
  if (NOT CONDA_PREFIX)
    cmake_path(SET CONDA_PREFIX "$ENV{CONDA_PREFIX}")
  endif()

  if(CONDA_PREFIX)
    if (WIN32)
      set(INCLUDE_DIRS "${CONDA_PREFIX}/Library/include")
      set(LIBRARY_DIRS "${CONDA_PREFIX}/Library/lib")
    else()
      set(INCLUDE_DIRS "${CONDA_PREFIX}/include")
      set(LIBRARY_DIRS "${CONDA_PREFIX}/lib")
    endif()
    find_package_brute(
      ${name} ${ARGN}
      HEADER_SEARCH_PATH ${INCLUDE_DIRS}
      LIBRARY_SEARCH_PATH ${LIBRARY_DIRS}
    )
  endif()

  propagate_cmake_library_variables("^${name}*")
endfunction()

function(find_package_pkgconfig name)
  set(options REQUIRED)
  set(oneValueArgs HEADER IMPORTED_TARGET)
  set(multiValueArgs LIBNAMES ADDITIONAL_PROPERTIES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  
  if (NOT ARGS_LIBNAMES)
    list(APPEND ARGS_LIBNAMES ${name})
  endif()
  if (NOT ARGS_HEADER)
    list(GET ARGS_LIBNAMES 0 FIRST_NAME)
    set(ARGS_HEADER ${FIRST_NAME}.h)
  endif()

  find_package(PkgConfig)
  set(pkg_check_args)
  if(ARGS_REQUIRED)
    list(APPEND pkg_check_args REQUIRED)
  # else()
  #   list(APPEND pkg_check_args QUIET)
  endif()
  # if(ARGS_IMPORTED_TARGET)
  #   list(APPEND pkg_check_args IMPORTED_TARGET ${ARGS_IMPORTED_TARGET})
  #   if(CMAKE_VERSION VERSION_GREATER_EQUAL "3.13")
  #     list(APPEND pkg_check_args GLOBAL)
  #   endif()
  # endif()
  set(PN "PC_${name}")
  pkg_check_modules(${PN} ${pkg_check_args} ${ARGS_LIBNAMES})
  if((NOT ${PN}_FOUND) AND ${PN}_STATIC_FOUND)
    # TODO: Finalize this separately & add alias?
    message(DEBUG "Using located static library for ${name}")
    set(PN "${PN}_STATIC")
  endif()
  message(DEBUG "${PN}_FOUND = ${${PN}_FOUND}")
  message(DEBUG "${PN}_INCLUDE_DIRS = ${${PN}_INCLUDE_DIRS}")
  message(DEBUG "${PN}_LIBRARY_DIRS = ${${PN}_LIBRARY_DIRS}")

  if(${PN}_FOUND)
    ## use the hints from above to find where 'lib*' & '*.h' are located
    dump_cmake_variables(REGEX "^${PN}*" OUTPUT_VAR PC_VARS VERBOSE)
    foreach(pcvar IN LISTS PC_VARS)
      string(REPLACE "${PN}" "${name}" ivar "${pcvar}")
      set(${ivar} "${${pcvar}}")
    endforeach()
    if(TARGET PkgConfig::${PN})
      add_library(${name} ALIAS PkgConfig::${PN})
    endif()
    if(${PN}_FOUND AND NOT ${name}_FOUND)
      message(FATAL_ERROR "Error setting variables from PC vars")
    endif()
  endif()
  if(${PN}_INCLUDE_DIRS)
    list(APPEND HEADER_SEARCH_PATH ${${PN}_INCLUDE_DIRS} ${${PN}_INCLUDE_DIRS}/*)
  endif()
  if(${PN}_LIBRARY_DIRS)
    list(APPEND LIBRARY_SEARCH_PATH ${${PN}_LIBRARY_DIRS} ${${PN}_LIBRARY_DIRS}/*)
  endif()
  find_package_brute(
    ${name} LIBNAMES ${ARGS_LIBNAMES} HEADER ${ARGS_HEADER}
    HEADER_SEARCH_PATH ${HEADER_SEARCH_PATH}
    LIBRARY_SEARCH_PATH ${LIBRARY_SEARCH_PATH}
  )
  finalize_package(
    ${name}
    HEADER ${ARGS_HEADER}
    LIBNAMES ${ARGS_LIBNAMES}
    IMPORTED_TARGET ${ARGS_IMPORTED_TARGET}
  )
  propagate_cmake_library_variables("^${name}*" ${ARGS_ADDITIONAL_PROPERTIES})
endfunction()

function(find_implib_from_dll dll VAR)
  get_filename_component(BIN_DIR ${dll} DIRECTORY)
  get_filename_component(PREFIX_DIR ${BIN_DIR} DIRECTORY)
  get_filename_component(BASE_NAME ${dll} NAME_WLE)
  find_library(
    implib
    NAMES ${BASE_NAME}
    PATHS ${PREFIX_DIR}/lib
  )
  if(NOT implib STREQUAL "implib-NOTFOUND")
    set(${VAR} ${implib} PARENT_SCOPE)
  endif()
endfunction()

function(find_dll_from_implib implib VAR)
  get_filename_component(LIB_DIR ${implib} DIRECTORY)
  get_filename_component(PREFIX_DIR ${LIB_DIR} DIRECTORY)
  get_filename_component(BASE_NAME ${implib} NAME_WLE)
  find_library(
    dll
    NAMES ${BASE_NAME}
    PATHS ${PREFIX_DIR}/bin
  )
  if(NOT dll STREQUAL "dll-NOTFOUND")
    set(${VAR} ${dll} PARENT_SCOPE)
  endif()
endfunction()

function(find_package_zmq)
  set(options REQUIRED)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  set(LIBNAMES zmq libzmq libzmq-static)
  set(HEADER zmq.h)
  set(IMPORTED_TARGET ZeroMQ)
  set(SEARCH_ARGS LIBNAMES ${LIBNAMES} HEADER ${HEADER}
      IMPORTED_TARGET ${IMPORTED_TARGET})
  if(WIN32)
    set(ARGS_REQUIRED ON)  # Force error
  endif()
  if(ARGS_REQUIRED)
    list(APPEND SEARCH_ARGS REQUIRED)
  endif()

  # Conda version has CMake config, but source code uses pkg-config
  find_package_generic(
    ZeroMQ ${SEARCH_ARGS}
    SEARCH_ORDER DEFAULT_CONFIG CONDA PKGCONFIG
  )

  # if (ZeroMQ_FOUND)
  #   if (WIN32 AND ZeroMQ_LIBRARY AND NOT TARGET ${ZeroMQ_LIBRARY})
  #     string(FIND ${ZeroMQ_LIBRARY} ".dll" ZeroMQ_DLL_POS)
  #     if (NOT "${ZeroMQ_DLL_POS}" STREQUAL "-1")
  #       message(DEBUG "Located ZeroMQ DLL: ${ZeroMQ_LIBRARY}")
  #       find_implib_from_dll(${ZeroMQ_LIBRARY} ZeroMQ_IMPLIB)
  #       message(DEBUG "Located ZeroMQ IMP: ${ZeroMQ_IMPLIB}")
  #     endif()
  #   endif()
  #   if(TARGET ZeroMQ)
  #     message(DEBUG "ZeroMQ is already TARGET")
  #   elseif(ZeroMQ_LIBRARY AND TARGET ${ZeroMQ_LIBRARY})
  #     message(DEBUG "ZeroMQ_LIBRARY is TARGET ${ZeroMQ_LIBRARY}")
  #     add_library(ZeroMQ ALIAS ${ZeroQM_LIBRARY})
  #   elseif(TARGET libzmq)
  #     message(DEBUG "libzmq target exists (ZeroMQ_LIBRARY = ${ZeroMQ_LIBRARY})")
  #     add_library(ZeroMQ ALIAS libzmq)
  #   elseif(TARGET libzmq-static)
  #     message(DEBUG "libzmq-static target exists (ZeroMQ_LIBRARY = ${ZeroMQ_LIBRARY})")
  #     add_library(ZeroMQ ALIAS libzmq-static)
  #   else()
  #     message(DEBUG "Creating ZeroMQ interface target ZeroMQ_LIBRARY = ${ZeroMQ_LIBRARY}, ZeroMQ_IMPLIB = ${ZeroMQ_IMPLIB}")
  #     create_interface_library(ZeroMQ)
  #     # if(ZeroMQ_IMPLIB)
  #     #   set_target_properties(
  #     #       ZeroMQ PROPERTIES
  #     #       IMPORTED_IMPLIB ${ZeroMQ_IMPLIB}
  #     #   )
  #     # endif()
  #   endif()
  # endif()
  # set(ZeroMQ_FOUND ${ZeroMQ_FOUND} PARENT_SCOPE)
  # set(ZeroMQ_LIBRARY ${ZeroMQ_LIBRARY} PARENT_SCOPE)
  # set(ZeroMQ_STATIC_LIBRARY ${ZeroMQ_STATIC_LIBRARY} PARENT_SCOPE)
  # set(ZeroMQ_INCLUDE_DIR ${ZeroMQ_INCLUDE_DIR} PARENT_SCOPE)
  propagate_cmake_library_variables("^ZeroMQ*")
endfunction()


function(check_suffixes filename output)
  set(multiValueArgs INCLUDE IGNORE)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  set(out true)
  if (ARGS_INCLUDE)
    set(out false)
    foreach(suffix IN LISTS ARGS_INCLUDE)
      if (filename MATCHES ".*${suffix}$")
        set(out true)
	break()
      endif()
    endforeach()
  endif()
  if (ARGS_IGNORE)
    foreach(suffix IN LISTS ARGS_IGNORE)
      if (filename MATCHES ".*${suffix}$")
        set(out false)
	break()
      endif()
    endforeach()
  endif()
  set(${output} ${out} PARENT_SCOPE)
endfunction()

function(list_search_directories output)
  set(options NO_DEFAULT_PATH NO_CMAKE_PATH NO_CMAKE_ENVIRONMENT_PATH NO_SYSTEM_ENVIRONMENT_PATH NO_CMAKE_INSTALL_PREFIX NO_CMAKE_SYSTEM_PATH NO_PACKAGE_ROOT_PATH)
  set(oneValueArgs FILETYPE)
  set(multiValueArgs PATHS HINTS PATH_SUFFIXES)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  set(${output})
  if (CMAKE_FIND_USE_CMAKE_PATH STREQUAL "FALSE")
    set(ARGS_NO_CMAKE_PATH true)
  endif()
  if (CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH STREQUAL "FALSE")
    set(ARGS_NO_CMAKE_ENVIRONMENT_PATH true)
  endif()
  if (CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH STREQUAL "FALSE")
    set(ARGS_NO_SYSTEM_ENVIRONMENT_PATH true)
  endif()
  if (CMAKE_FIND_USE_INSTALL_PREFIX STREQUAL "FALSE")
    set(ARGS_NO_CMAKE_INSTALL_PREFIX true)
  endif()
  if (CMAKE_FIND_USE_CMAKE_SYSTEM_PATH STREQUAL "FALSE")
    set(ARGS_NO_CMAKE_SYSTEM_PATH true)
  endif()
  if (CMAKE_FIND_USE_PACKAGE_ROOT_PATH STREQUAL "FALSE")
    set(ARGS_NO_PACKAGE_ROOT_PATH true)
  endif()
  if (ARGS_FILETYPE STREQUAL "SHARED")
    if (WIN32)
      set(suffix "bin")
    else()
      set(suffix "lib")
    endif()
    set(pathvar "CMAKE_LIBRARY_PATH")
    set(syspathvar "CMAKE_SYSTEM_LIBRARY_PATH")
    set(envvar "LIB")
  elseif (ARGS_FILETYPE STREQUAL "STATIC" OR
          ARGS_FILETYPE STREQUAL "IMPORT")
    set(suffix "lib")
    set(pathvar "CMAKE_LIBRARY_PATH")
    set(syspathvar "CMAKE_SYSTEM_LIBRARY_PATH")
    set(envvar "LIB")
  else()
    set(suffix "include")
    set(pathvar "CMAKE_INCLUDE_PATH")
    set(syspathvar "CMAKE_SYSTEM_INCLUDE_PATH")
    set(envvar "INCLUDE")
  endif()
  # 1. Package root
  # if (NOT (ARGS_NO_DEFAULT_PATH OR ARGS_NO_PACKAGE_ROOT_PATH))
  # endif()
  # 2. & 3. cmake variables
  if (NOT (ARGS_NO_DEFAULT_PATH OR (ARGS_NO_CMAKE_PATH AND ARGS_NO_CMAKE_ENVIRONMENT_PATH)))
    if (DEFINED ENV{CONDA_PREFIX})
      set(mingw64 "$ENV{CONDA_PREFIX}")
      set(mingw32 "$ENV{CONDA_PREFIX}")
      cmake_path(APPEND mingw64
                 "$ENV{CONDA_PREFIX}" "Library" "mingw-w64")
      cmake_path(APPEND mingw32 ${mingw64} "x86_64-w64-mingw32")
      list(APPEND conda_prefixes ${mingw32} ${mingw64} $ENV{CONDA_PREFIX})
      foreach(prefix IN LISTS conda_prefixes)
        if ((EXISTS ${prefix}) AND (NOT ${prefix} IN_LIST CMAKE_PREFIX_PATH))
	  list(INSERT CMAKE_PREFIX_PATH 0 ${prefix})
	endif()
      endforeach()
      if (NOT $ENV{CONDA_PREFIX} IN_LIST CMAKE_PREFIX_PATH)
        list(INSERT CMAKE_PREFIX_PATH 0 $ENV{CONDA_PREFIX})
      endif()
    endif()
    foreach(prefix IN LISTS CMAKE_PREFIX_PATH)
      if (NOT (${prefix} IN_LIST CMAKE_IGNORE_PREFIX_PATH) OR
              (${prefix} IN_LIST CMAKE_SYSTEM_IGNORE_PREFIX_PATH))
        if (CMAKE_LIBRARY_ARCHITECTURE)
          cmake_path(APPEND prefix ${suffix}
  	             ${CMAKE_LIBRARY_ARCHITECTURE} OUTPUT_VARIABLE tmp)
  	  if (NOT (${tmp} IN_LIST CMAKE_IGNORE_PATH) OR
	          (${tmp} IN_LIST CMAKE_SYSTEM_IGNORE_PATH))
            list(APPEND ${output} ${tmp})
	  endif()
        endif()
        cmake_path(APPEND prefix ${suffix} OUTPUT_VARIABLE tmp)
	if (NOT (${tmp} IN_LIST CMAKE_IGNORE_PATH) OR
	        (${tmp} IN_LIST CMAKE_SYSTEM_IGNORE_PATH))
          list(APPEND ${output} ${tmp})
	endif()
      endif()
    endforeach()
    foreach(tmp IN LISTS ${pathvar} CMAKE_FRAMEWORK_PATH)
      if (NOT (${tmp} IN_LIST CMAKE_IGNORE_PATH) OR
              (${tmp} IN_LIST CMAKE_SYSTEM_IGNORE_PATH))
        list(APPEND ${output} ${tmp})
      endif()
    endforeach()
  endif()
  # 4. User specified hints
  list(APPEND ${output} ${ARGS_HINTS})
  # 5. Environment variables
  if (NOT (ARGS_NO_DEFAULT_PATH OR ARGS_NO_SYSTEM_ENVIRONMENT_PATH))
    if (DEFINED ENV{${envvar}})
      string(REPLACE ":" ";" ENVVAR_LIST $ENV{${envvar}})
    endif()
    if (DEFINED ENV{PATH})
      string(REPLACE ":" ";" PATH_LIST $ENV{PATH})
    endif()
    foreach(tmp IN LISTS ENVVAR_LIST PATH_LIST)
      if (NOT (${tmp} IN_LIST CMAKE_IGNORE_PATH) OR
              (${tmp} IN_LIST CMAKE_SYSTEM_IGNORE_PATH))
	list(APPEND ${output} ${tmp})
      endif()
    endforeach()
  endif()
  # Behavior removed in CMake 3.28
  # Search <prefix>/${suffix} and <prefix>/${suffix}/<arch> for each <prefix>/[s]bin in PATH
  # 6. Variables in platform files
  if (NOT (ARGS_NO_DEFAULT_PATH OR ARGS_NO_CMAKE_SYSTEM_PATH))
    foreach(prefix IN LISTS CMAKE_SYSTEM_PREFIX_PATH)
      if (NOT (${prefix} IN_LIST CMAKE_IGNORE_PREFIX_PATH) OR
              (${prefix} IN_LIST CMAKE_SYSTEM_IGNORE_PREFIX_PATH))
        if (CMAKE_LIBRARY_ARCHITECTURE)
          cmake_path(APPEND prefix ${suffix}
	             ${CMAKE_LIBRARY_ARCHITECTURE} OUTPUT_VARIABLE tmp)
          if (NOT (${tmp} IN_LIST CMAKE_IGNORE_PATH) OR
                  (${tmp} IN_LIST CMAKE_SYSTEM_IGNORE_PATH))
            list(APPEND ${output} ${tmp})
	  endif()
        endif()
        cmake_path(APPEND prefix ${suffix} OUTPUT_VARIABLE tmp)
        if (NOT (${tmp} IN_LIST CMAKE_IGNORE_PATH) OR
                (${tmp} IN_LIST CMAKE_SYSTEM_IGNORE_PATH))
          list(APPEND ${output} ${tmp})
	endif()
      endif()
    endforeach()
    foreach(tmp IN LISTS ${syspathvar} CMAKE_SYSTEM_FRAMEWORK_PATH)
      if (NOT (${tmp} IN_LIST CMAKE_IGNORE_PATH) OR
              (${tmp} IN_LIST CMAKE_SYSTEM_IGNORE_PATH))
        list(APPEND ${output} ${tmp})
      endif()
    endforeach()
    if (NOT ARGS_NO_CMAKE_INSTALL_PREFIX)
      foreach(prefix IN LISTS CMAKE_INSTALL_PREFIX CMAKE_STAGING_PREFIX)
        if (NOT (${prefix} IN_LIST CMAKE_IGNORE_PREFIX_PATH) OR
                (${prefix} IN_LIST CMAKE_SYSTEM_IGNORE_PREFIX_PATH))
          list(APPEND ${output} ${prefix})
	endif()
      endforeach()
    endif()
  endif()
  # 7. User specified paths
  list(APPEND ${output} ${ARGS_PATHS})
  # PATH_SUFFIXES
  if (ARGS_PATH_SUFFIXES)
    foreach(dir IN LISTS ${output})
      list(APPEND new_output ${dir})
      foreach(suffix IN LISTS ${ARGS_PATH_SUFFIXES})
        cmake_path(APPEND dir ${suffix} OUTPUT_VARIABLE tmp)
        list(APPEND new_output ${tmp})
      endforeach()
    endforeach()
    set(${output} ${new_output})
  endif()
  list(REMOVE_DUPLICATES ${output})
  set(${output} ${${output}} PARENT_SCOPE)
endfunction()

function(find_library_suffix output libname libtype)
  set(options NO_CACHE REQUIRED)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  if(${output} AND NOT ARGS_NO_CACHE)
    return()
  endif()
  if (NOT libtype STREQUAL "SHARED")
    find_library(${output} ${libname} ${ARGS_UNPARSED_ARGUMENTS} NO_CACHE)
    message(DEBUG "find_library_suffix: Trying find_library ${libname}")
  else()
    set(${output} "${output}-NOTFOUND")
  endif()
  if (${${output}} STREQUAL "${output}-NOTFOUND")
    set(${output})
    set(prefix)
    set(suffix)
    if (libtype STREQUAL "SHARED" OR
        libtype STREQUAL "STATIC" OR
        libtype STREQUAL "IMPORT")
      set(prefix ${CMAKE_${libtype}_LIBRARY_PREFIX})
      set(suffix ${CMAKE_${libtype}_LIBRARY_SUFFIX})
    elseif (libtype STREQUAL "OBJECT")
      set(prefix)
      set(suffix ${CMAKE_C_OUTPUT_EXTENSION})
    else()
      message(FATAL_ERROR "Invalid libtype ${libtype}")
    endif()
    message(DEBUG "find_library_suffix: Trying find_file ${prefix}${libname}${suffix}")
    find_file(${output} "${prefix}${libname}${suffix}" ${ARGS_UNPARSED_ARGUMENTS} NO_CACHE)
  endif()
  if (${${output}} STREQUAL "${output}-NOTFOUND")
    set(${output})
    message(DEBUG "find_library_suffix: Trying find_file_regex ${prefix}${libname}*${suffix}")
    find_file_regex(${output} "${prefix}${libname}*${suffix}"
                    FILETYPE ${libtype} ${ARGS_UNPARSED_ARGUMENTS}
		    NO_CACHE)
  endif()
  if (${output} STREQUAL "${output}-NOTFOUND")
    if (ARGS_REQUIRED)
      message(FATAL_ERROR "Could not locate a library file for ${libname}")
    endif()
  else()
    message(DEBUG "find_library_suffix: Found library file for ${libname}: ${${output}}")
  endif()
  if (NOT ARGS_NO_CACHE)
    set(${output} "${${output}}" CACHE FILEPATH "The location of the library file for ${libname}")
  else()
    set(${output} "${${output}}" PARENT_SCOPE)
  endif()
endfunction()

function(find_file_regex output pattern)
  set(options NO_CACHE REQUIRED)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  if(${output} AND NOT ARGS_NO_CACHE)
    return()
  endif()
  list_search_directories(search_dirs ${ARGS_UNPARSED_ARGUMENTS})
  foreach(dir IN LISTS search_dirs)
    cmake_path(APPEND dir ${pattern} OUTPUT_VARIABLE iregex)
    file(GLOB matches LIST_DIRECTORIES false ${iregex})
    foreach(match IN LISTS matches)
      set(${output} ${match})
      break()
    endforeach()
    if (${output})
      break()
    endif()
  endforeach()
  if (NOT ${output})
    set(${output} "${output}-NOTFOUND")
    if (ARGS_REQUIRED)
      message(FATAL_ERROR "Could not locate a file matching the pattern ${pattern}")
    endif()
  else()
  endif()
  if (NOT ARGS_NO_CACHE)
    set(${output} "${${output}}" CACHE FILEPATH "The location of the file matching the regex ${pattern}")
  else()
    set(${output} "${${output}}" PARENT_SCOPE)
  endif()
endfunction()

function(find_libraries)
  set(multiValueArgs LIBRARIES DIRECTORIES
      INCLUDE_SUFFIXES IGNORE_SUFFIXES)
  set(oneValueArgs OUTPUT MISSING MISMATCHED_SUFFIX LIBTYPE)
  cmake_parse_arguments(ARGS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
  if (NOT ARGS_LIBTYPE)
    if (WIN32)
      set(ARGS_LIBTYPE IMPORT)
    else()
      set(ARGS_LIBTYPE SHARED)
    endif()
  endif()
  list(APPEND ARGS_LIBRARIES ${ARGS_UNPARSED_ARGUMENTS})
  set(LIBS_FULL)
  set(LIBS_MISS)
  set(LIBS_UNMT)
  foreach(x IN LISTS ARGS_LIBRARIES)
    find_library_suffix(${x}_FOUND ${x} ${ARGS_LIBTYPE}
                        PATHS ${ARGS_DIRECTORIES})
    if(${x}_FOUND STREQUAL "${x}_FOUND-NOTFOUND")
      list(APPEND LIBS_MISS ${${x}_FOUND})
    else()
      message(STATUS "Looking for ${x}: ${x}_FOUND = ${${x}_FOUND}")
      check_suffixes(${${x}_FOUND} add_x
                     INCLUDE ${ARGS_INCLUDE_SUFFIXES}
		     IGNORE ${ARGS_IGNORE_SUFFIXES})
      if (add_x)
        list(APPEND LIBS_FULL ${${x}_FOUND})
      else()
        message(DEBUG "Suffix does not match (include=${ARGS_INCLUDE_SUFFIXES}, ignore=${ARGS_IGNORE_SUFFIXES})")
        list(APPEND LIBS_UNMT ${x})
      endif()
    endif()
  endforeach()
  if (ARGS_OUTPUT)
    set(${ARGS_OUTPUT} ${LIBS_FULL} PARENT_SCOPE)
  endif()
  if (ARGS_MISSING)
    set(${ARGS_MISSING} ${LIBS_MISS} PARENT_SCOPE)
  endif()
  if (ARGS_MISMATCHED_SUFFIX)
    set(${ARGS_MISMATCHED_SUFFIX} ${LIBS_UNMT} PARENT_SCOPE)
  endif()
endfunction()
